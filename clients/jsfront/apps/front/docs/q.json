C({"plugin": undefined, "name": "q", "className": "attribute", "comment": "ajax: function( origSettings ) {\n\t\tvar s = jQuery.extend(true, {}, jQuery.ajaxSettings, origSettings),\n\t\t\tjsonp, status, data, type = s.type.toUpperCase(), noContent = rnoContent.test(type);\n\n\t\ts.url = s.url.replace( rhash, \"\" );\n\n\t\t// Use original (not extended) context object if it was provided\n\t\ts.context = origSettings && origSettings.context != null ? origSettings.context : s;\n\n\t\t// convert data if not already a string\n\t\tif ( s.data && s.processData && typeof s.data !== \"string\" ) {\n\t\t\ts.data = jQuery.param( s.data, s.traditional );\n\t\t}\n\n\t\t// Handle JSONP Parameter Callbacks\n\t\tif ( s.dataType === \"jsonp\" ) {\n\t\t\tif ( type === \"GET\" ) {\n\t\t\t\tif ( !jsre.test( s.url ) ) {\n\t\t\t\t\ts.url += (rquery.test( s.url ) ? \"&\" : \"?\") + (s.jsonp || \"callback\") + \"=?\";\n\t\t\t\t}\n\t\t\t} else if ( !s.data || !jsre.test(s.data) ) {\n\t\t\t\ts.data = (s.data ? s.data + \"&\" : \"\") + (s.jsonp || \"callback\") + \"=?\";\n\t\t\t}\n\t\t\ts.dataType = \"json\";\n\t\t}\n\n\t\t// Build temporary JSONP function\n\t\tif ( s.dataType === \"json\" && (s.data && jsre.test(s.data) || jsre.test(s.url)) ) {\n\t\t\tjsonp = s.jsonpCallback || (\"jsonp\" + jsc++);\n\n\t\t\t// Replace the =? sequence both in the query string and the data\n\t\t\tif ( s.data ) {\n\t\t\t\ts.data = (s.data + \"\").replace(jsre, \"=\" + jsonp + \"$1\");\n\t\t\t}\n\n\t\t\ts.url = s.url.replace(jsre, \"=\" + jsonp + \"$1\");\n\n\t\t\t// We need to make sure\n\t\t\t// that a JSONP style response is executed properly\n\t\t\ts.dataType = \"script\";\n\n\t\t\t// Handle JSONP-style loading\n\t\t\tvar customJsonp = window[ jsonp ];\n\n\t\t\twindow[ jsonp ] = function( tmp ) {\n\t\t\t\tif ( jQuery.isFunction( customJsonp ) ) {\n\t\t\t\t\tcustomJsonp( tmp );\n\n\t\t\t\t} else {\n\t\t\t\t\t// Garbage collect\n\t\t\t\t\twindow[ jsonp ] = undefined;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdelete window[ jsonp ];\n\t\t\t\t\t} catch( jsonpError ) {}\n\t\t\t\t}\n\n\t\t\t\tdata = tmp;\n\t\t\t\tjQuery.handleSuccess( s, xhr, status, data );\n\t\t\t\tjQuery.handleComplete( s, xhr, status, data );\n\n\t\t\t\tif ( head ) {\n\t\t\t\t\thead.removeChild( script );\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tif ( s.dataType === \"script\" && s.cache === null ) {\n\t\t\ts.cache = false;\n\t\t}\n\n\t\tif ( s.cache === false && noContent ) {\n\t\t\tvar ts = jQuery.now();\n\n\t\t\t// try replacing _= if it is there\n\t\t\tvar ret = s.url.replace(rts, \"$1_=\" + ts);\n\n\t\t\t// if nothing was replaced, add timestamp to the end\n\t\t\ts.url = ret + ((ret === s.url) ? (rquery.test(s.url) ? \"&\" : \"?\") + \"_=\" + ts : \"\");\n\t\t}\n\n\t\t// If data is available, append data to url for GET/HEAD requests\n\t\tif ( s.data && noContent ) {\n\t\t\ts.url += (rquery.test(s.url) ? \"&\" : \"?\") + s.data;\n\t\t}\n\n\t\t// Watch for a new set of requests\n\t\tif ( s.global && jQuery.active++ === 0 ) {\n\t\t\tjQuery.event.trigger( \"ajaxStart\" );\n\t\t}\n\n\t\t// Matches an absolute URL, and saves the domain\n\t\tvar parts = rurl.exec( s.url ),\n\t\t\tremote = parts && (parts[1] && parts[1].toLowerCase() !== location.protocol || parts[2].toLowerCase() !== location.host);\n\n\t\t// If we're requesting a remote document\n\t\t// and trying to load JSON or Script with a GET\n\t\tif ( s.dataType === \"script\" && type === \"GET\" && remote ) {\n\t\t\tvar head = document.getElementsByTagName(\"head\")[0] || document.documentElement;\n\t\t\tvar script = document.createElement(\"script\");\n\t\t\tif ( s.scriptCharset ) {\n\t\t\t\tscript.charset = s.scriptCharset;\n\t\t\t}\n\t\t\tscript.src = s.url;\n\n\t\t\t// Handle Script loading\n\t\t\tif ( !jsonp ) {\n\t\t\t\tvar done = false;\n\n\t\t\t\t// Attach handlers for all browsers\n\t\t\t\tscript.onload = script.onreadystatechange = function() {\n\t\t\t\t\tif ( !done && (!this.readyState ||\n\t\t\t\t\t\t\tthis.readyState === \"loaded\" || this.readyState === \"complete\") ) {\n\t\t\t\t\t\tdone = true;\n\t\t\t\t\t\tjQuery.handleSuccess( s, xhr, status, data );\n\t\t\t\t\t\tjQuery.handleComplete( s, xhr, status, data );\n\n\t\t\t\t\t\t// Handle memory leak in IE\n\t\t\t\t\t\tscript.onload = script.onreadystatechange = null;\n\t\t\t\t\t\tif ( head && script.parentNode ) {\n\t\t\t\t\t\t\thead.removeChild( script );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Use insertBefore instead of appendChild  to circumvent an IE6 bug.\n\t\t\t// This arises when a base node is used (#2709 and #4378).\n\t\t\thead.insertBefore( script, head.firstChild );\n\n\t\t\t// We handle everything using the script element injection\n\t\t\treturn undefined;\n\t\t}\n\n\t\tvar requestDone = false;\n\n\t\t// Create the request object\n\t\tvar xhr = s.xhr();\n\n\t\tif ( !xhr ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Open the socket\n\t\t// Passing null username, generates a login popup on Opera (#2865)\n\t\tif ( s.username ) {\n\t\t\txhr.open(type, s.url, s.async, s.username, s.password);\n\t\t} else {\n\t\t\txhr.open(type, s.url, s.async);\n\t\t}\n\n\t\t// Need an extra try/catch for cross domain requests in Firefox 3\n\t\ttry {\n\t\t\t// Set content-type if data specified and content-body is valid for this type\n\t\t\tif ( (s.data != null && !noContent) || (origSettings && origSettings.contentType) ) {\n\t\t\t\txhr.setRequestHeader(\"Content-Type\", s.contentType);\n\t\t\t}\n\n\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\tif ( s.ifModified ) {\n\t\t\t\tif ( jQuery.lastModified[s.url] ) {\n\t\t\t\t\txhr.setRequestHeader(\"If-Modified-Since\", jQuery.lastModified[s.url]);\n\t\t\t\t}\n\n\t\t\t\tif ( jQuery.etag[s.url] ) {\n\t\t\t\t\txhr.setRequestHeader(\"If-None-Match\", jQuery.etag[s.url]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set header so the called script knows that it's an XMLHttpRequest\n\t\t\t// Only send the header if it's not a remote XHR\n\t\t\tif ( !remote ) {\n\t\t\t\txhr.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\");\n\t\t\t}\n\n\t\t\t// Set the Accepts header for the server, depending on the dataType\n\t\t\txhr.setRequestHeader(\"Accept\", s.dataType && s.accepts[ s.dataType ] ?\n\t\t\t\ts.accepts[ s.dataType ] + \", \n"})